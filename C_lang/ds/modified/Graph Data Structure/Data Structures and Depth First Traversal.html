
<!DOCTYPE html>
<html>

<head>
  <title>Introduction to C</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">


  <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.0/umd/popper.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.1.0/js/bootstrap.min.js"></script>

  <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>


  <link rel="stylesheet" href="https://raw.githubusercontent.com/ranickpatra/all_apps_data/master/C_lang/ds/modified/style/style1.css">
  <link rel="stylesheet" href="https://raw.githubusercontent.com/ranickpatra/all_apps_data/master/C_lang/ds/modified/style/style2.css">


</head>

<body>

  <div class="container">

<div class="col-md-7 middle-col" style="height: 2593px;">
<h1>Data Structure - Depth First Traversal</h1>

<hr/>



<hr/>
<p>Depth First Search (DFS) algorithm traverses a graph in a depthward motion and uses a stack to remember to get the next vertex to start a search, when a dead end occurs in any iteration.</p>
<img alt="Depth First Travesal" src="https://raw.githubusercontent.com/ranickpatra/all_apps_data/master/C_lang/ds/modified/images//depth_first_traversal.jpg"/>
<p>As in the example given above, DFS algorithm traverses from S to A to D to G to E to B first, then to F and lastly to C. It employs the following rules.</p>
<ul class="list">
<li><p><b>Rule 1</b> − Visit the adjacent unvisited vertex. Mark it as visited. Display it. Push it in a stack.</p></li>
<li><p><b>Rule 2</b> − If no adjacent vertex is found, pop up a vertex from the stack. (It will pop up all the vertices from the stack, which do not have adjacent vertices.)</p></li>
<li><p><b>Rule 3</b> − Repeat Rule 1 and Rule 2 until the stack is empty.</p></li>
</ul>
<table class="table table-bordered">
<tbody><tr>
<th style="text-align:center;">Step</th>
<th style="text-align:center;">Traversal</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td class="ts" style="width:5%;">1</td>
<td style="width:50%"><img alt="Depth First Search Step One" src="https://raw.githubusercontent.com/ranickpatra/all_apps_data/master/C_lang/ds/modified/images//dfs_one.jpg"/></td>
<td style="vertical-align:middle;">Initialize the stack.</td>
</tr>
<tr>
<td class="ts" style="width:5%;">2</td>
<td style="width:50%"><img alt="Depth First Search Step Two" src="https://raw.githubusercontent.com/ranickpatra/all_apps_data/master/C_lang/ds/modified/images//dfs_two.jpg"/></td>
<td style="vertical-align:middle;">Mark <b>S</b> as visited and put it onto the stack. Explore any unvisited adjacent node from <b>S</b>. We have three nodes and we can pick any of them. For this example, we shall take the node in an alphabetical order.</td>
</tr>
<tr>
<td class="ts" style="width:5%;">3</td>
<td style="width:50%"><img alt="Depth First Search Step Three" src="https://raw.githubusercontent.com/ranickpatra/all_apps_data/master/C_lang/ds/modified/images//dfs_three.jpg"/></td>
<td style="vertical-align:middle;">Mark <b>A</b> as visited and put it onto the stack. Explore any unvisited adjacent node from A. Both <b>S</b> and <b>D</b> are adjacent to <b>A</b> but we are concerned for unvisited nodes only.</td>
</tr>
<tr>
<td class="ts" style="width:5%;">4</td>
<td style="width:50%"><img alt="Depth First Search Step Four" src="https://raw.githubusercontent.com/ranickpatra/all_apps_data/master/C_lang/ds/modified/images//dfs_four.jpg"/></td>
<td style="vertical-align:middle;">Visit <b>D</b> and mark it as visited and put onto the stack. Here, we have <b>B</b> and <b>C</b> nodes, which are adjacent to <b>D</b> and both are unvisited. However, we shall again choose in an alphabetical order.</td>
</tr>
<tr>
<td class="ts" style="width:5%;">5</td>
<td style="width:50%"><img alt="Depth First Search Step Five" src="https://raw.githubusercontent.com/ranickpatra/all_apps_data/master/C_lang/ds/modified/images//dfs_five.jpg"/></td>
<td style="vertical-align:middle;">We choose <b>B</b>, mark it as visited and put onto the stack. Here <b>B</b> does not have any unvisited adjacent node. So, we pop <b>B</b> from the stack.</td>
</tr>
<tr>
<td class="ts" style="width:5%;">6</td>
<td style="width:50%"><img alt="Depth First Search Step Six" src="https://raw.githubusercontent.com/ranickpatra/all_apps_data/master/C_lang/ds/modified/images//dfs_six.jpg"/></td>
<td style="vertical-align:middle;">We check the stack top for return to the previous node and check if it has any unvisited nodes. Here, we find <b>D</b> to be on the top of the stack.</td>
</tr>
<tr>
<td class="ts" style="width:5%;">7</td>
<td style="width:50%"><img alt="Depth First Search Step Seven" src="https://raw.githubusercontent.com/ranickpatra/all_apps_data/master/C_lang/ds/modified/images//dfs_seven.jpg"/></td>
<td style="vertical-align:middle;">Only unvisited adjacent node is from <b>D</b> is <b>C</b> now. So we visit <b>C</b>, mark it as visited and put it onto the stack.</td>
</tr>
</tbody></table>
<p>As <b>C</b> does not have any unvisited adjacent node so we keep popping the stack until we find a node that has an unvisited adjacent node. In this case, there's none and we keep popping until the stack is empty.</p>
<p>To know about the implementation of this algorithm in C programming language, <a href="https://www.tutorialspoint.com/data_structures_algorithms/depth_first_traversal_in_c.htm">click here</a>.</p>
<hr/>



<hr/>
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead" style="display: none !important;">
<div class="bottomadtag" style="display: none !important;">Advertisements</div>
<!-- /60931893/tutorial_bottom_leader_board -->
<div id="div-gpt-ad-1510138782906-3">
<script>
googletag.cmd.push(function() { googletag.display('div-gpt-ad-1510138782906-3'); });
</script>
</div>
</div>
</div>

  </div>

</body>

</html>


